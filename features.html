<!DOCTYPE html>
<html>
<head>
    <title>C# - Features</title>
    <link rel="icon" type="image/x-icon" href="img/favicon.png"/>
    <link rel="stylesheet" media="screen" href="css/219.css">

    <script src="js/jquery-2.2.3.min.js"></script>
    <script src="js/build-menu.js"></script>
    <script src="js/font-stuff.js"></script>
    <script src="js/key-advance.js"></script>
</head>

<body>
<div class="page-wrapper">

    <section class="intro">
        <header role="banner">
            <a href="index.html"><img src="img/c.png" alt="C#"></a>
            <h1>Features</h1>
        </header>
    </section>

    <div id="right-key-advance">
        <div id="right-1">
            <h3>Arrays</h3>
            <ul>
                <li>Numerically indexed starting with 0.</li>
                <li>For associative arrays use library class (HashMap, Dictionary).</li>
                <li>All arrays are actually objects. Inherit from Array base class.</li>
                <li>
                    Two basic types of arrays:
<pre>
// Rectangular array syntax.
int[,] rectangle =
    new int[,] { {1, 2}, {3, 4} };

// Jagged array syntax.
int[][] jagged =
    { new int[] {1,2}, new int[] {3,4} };
</pre>
                </li>
            </ul>
        </div>

        <div id="right-2">
            <h3>Constructors</h3>
            <ul>
                <li>
                    Similar to constructors in Java.
<!-- Note: These can't be indented :/ -->
<pre>
// Example constructor declaration.
public Point() {

}
</pre>
<pre>
// Example constructor invocation.
Point myPoint = new Point();
</pre>
                </li>
            </ul>
        </div>

        <div id="right-3">
            <h3>Destructors</h3>
            <ul>
                <li>
                    Special methods used to destruct instances of classes.
                </li>
                <li>
                    Only necessary when encapsulation unmanaged resources (windows, files, network connections).
                </li>
                <li>
                    Invoked when the .NET garbage collector determines that the object is no longer being used.
<pre>
// Example destructor declaration.
~ Point() {
    // Cleanup statements.
}
</pre>
                </li>
            </ul>
        </div>


        <div id="right-4">
            <h3>Lambda Expressions</h3>
            <ul>
                <li>
                    Lambda expressions are powerful anonymous functions
<pre>
// Used in Fibonacci.cs example.
Func<int, int> fib = null;
fib = p => p > 1 ? fib(p - 2) + fib(p - 1) : p;
</pre>
                </li>
            </ul>
        </div>

        <div id="right-5">
            <h3>Properties</h3>
            <ul>
                <li>
                    Can be used as if they are public data members, but actually use accessor methods.
<pre>
// Setup
class TimePeriod {
    private double seconds;

    public double Hours {
        get { return seconds / 3600; }
        set { seconds = value * 3600; } // 'value' is special keyword.
    }
}

// Usage.
TimePeriod time = new TimePeriod();
time.Hours = 24; // Invoke set.
Console.WriteLine("Time in hours: " + t.Hours); // Invoke get.
</pre>
                </li>
            </ul>
        </div>

        <div id="right-6">
            <h3>Switch Statement Oddities</h3>
            <!--<ul>-->
                <!--<li>No tail recursion.</li>-->
            <!--</ul>-->
            <ul>
                <li>
                    No fall-through in switch statements (unless you like hacks).
<pre>
switch (number) {
    case 1:
        Console.WriteLine("OK!");
        break;
    case 2:
        Console.WriteLine("Illegal!");
        // Missing break, wont compile.
    case 3:
        Console.WriteLine("Weird!");
        goto case 1;
    case 4: // setup for case 5
        string s;
        break;
    case 5:
        s = "What just happened?"; // 's' defined in case 4.
        break;
    default:
        break; // Yep even defaults need break.
}
</pre>
                </li>
            </ul>
        </div>

        <div id="right-7">
            <h3>Boxing and Unboxing</h3>
            <ul>
                <li>
                    Value of any type can be treated as an object.
                </li>
                <li>
                    Boxing wraps a value type inside a System.Object and stores it on the heap.
                </li>
                <li>
                    Similar to casting, but without truncation.
                </li>
                <li>
                    Viewed as way to allow value types to temporarily become reference types.
                </li>
                <li>
<pre>
int i = 123;
object o = i; // Boxing of i.

o = 123;
i = (int)o;  // Unboxing.
</pre>
                </li>
            </ul>
        </div>

        <div id="right-8">
            <h3>Operator overloading</h3>
            <ul>
                <li>
                    Custom operator actions for reference types.
<pre>
// Overload + operator to add two Box objects.
public static Box operator+ (Box b, Box c) {
    Box box = new Box();
    box.length = b.length + c.length;
    box.breadth = b.breadth + c.breadth;
    box.height = b.height + c.height;
    return box;
}
</pre>
                </li>
            </ul>
        </div>

        <div id="right-9">
            <h3>Some notes</h3>
            <ul>
                <li>
                    Can switch on strings
                </li>
            </ul>
        </div>
    </div>

    <div id="left">
        <!-- Left menu filled in by js. -->
    </div>

</div>

</body>
</html>
